# v1.2.23 - 诊断与推断改进 (Diagnostic & Inference Improvements)

## 构建信息 (Build Info)
- **版本**: v1.2.23
- **构建时间**: 2025-12-13 19:27:36 UTC
- **可执行文件**: `UniversalEmailCleaner_v1.2.23.exe` (28.9 MB)
- **位置**: `Q:\Dev\Python\TestEnv1\Projects\Python\UniversalEmailCleaner\dist\`

---

## 1. 关键诊断改进 (Critical Diagnostic Improvements)

### 1.1 增强 Advanced 日志输出

**问题**：之前的日志没有显示 Python 类型信息和 ItemClass，无法判断是否为标准 IPM.Appointment 或其他非标准项类（如 IPM.Schedule.Meeting.Request）。

**解决方案**：Advanced 日志现在包括 4 个关键诊断字段：

```python
if self.log_level_var.get() == "Advanced":
    self.log(
        f"[EWS] ItemFields: "
        f"PyType={type(item)} "              # 实际 Python 对象类型
        f"ClassName={item.__class__.__name__} "  # 类名
        f"ItemClass={getattr(item, 'item_class', None)} "  # EWS ItemClass (IPM.*)
        f"Type={getattr(item, 'calendar_item_type', None)} "  # CalendarItemType
        f"UID={getattr(item, 'uid', None)} "
        f"RecurringMasterId={getattr(item, 'recurring_master_id', None)} "
        f"IsRecurring={getattr(item, 'is_recurring', None)} "
        f"HasRecurrence={getattr(item, 'recurrence', None) is not None}",
        is_advanced=True
    )
```

**用途**：运行时在 Advanced 日志中查看：
- 如果 `ItemClass` 不是 `IPM.Appointment`（如 `IPM.Schedule.Meeting.Request`），说明这是非标准项。
- 此时 `calendar_item_type` 很可能为 `None`，这是正常的。
- 通过 `PyType`、`ClassName` 可以确认实际类型。

### 1.2 改进 TraceAdapter 响应记录

**问题**：之前响应体经常显示为 `False` 或空，无法确认服务端是否返回了 `<t:CalendarItemType>` 值。

**解决方案**：
- 优先捕获 `response._content` 或 `response.content`
- 完整的 XML 响应体被记录到日志
- 若超过 50KB，截断并提示查看完整日志文件
- 日志标签改为 `<Trace Tag="EwsResponse" ...>` 格式，包含完整的 XML 内容

**用途**：查看 EWS 日志，搜索 `<Trace Tag="EwsResponse"` 可看到完整响应，特别是 GetItem 操作的结果。

---

## 2. 类型检测推断逻辑 (Type Detection Inference)

### 问题
若 `calendar_item_type` 为空（比如项是 IPM.Schedule.Meeting.Request 而非标准 IPM.Appointment），之前代码会：
- 在 scope 过滤时因为 `c_type is None` 直接 pass，无法过滤
- Type 显示为 `None` 或 `Unknown`
- 无法判断该项是 Single 还是 Occurrence

### 解决方案

#### 2.1 Scope 过滤中的推断

替换原来的硬依赖 `calendar_item_type` 的逻辑：

```python
# 原来的逻辑（有缺陷）:
c_type = getattr(item, 'calendar_item_type', None)
if c_type is None:
    pass  # 无法判断，只能 pass
else:
    if "Single" in scope and c_type != 'Single': continue
    # ...

# 新的推断逻辑：
ci_type = getattr(item, 'calendar_item_type', None)
inferred_type = ci_type

# 若拿不到，就推断
if not inferred_type:
    rec = getattr(item, 'recurrence', None)
    master_id = getattr(item, 'recurring_master_id', None)
    is_rec = getattr(item, 'is_recurring', None)
    
    if rec:
        inferred_type = "RecurringMaster"
    elif master_id:
        inferred_type = "Occurrence"
    elif is_rec is False:
        inferred_type = "Single"
    else:
        inferred_type = "Unknown"

# 使用 inferred_type 进行过滤
if "Single" in scope and inferred_type != 'Single': continue
elif "Series" in scope and inferred_type not in ('RecurringMaster', 'Occurrence'): continue
```

#### 2.2 行详情中的推断和追踪

在构建报告行时，代码也使用同样的推断逻辑，并在 Advanced 模式下记录：

```python
ci_type = getattr(item, 'calendar_item_type', None)
m_type = ci_type

if not m_type:
    rec = getattr(item, 'recurrence', None)
    master_id = getattr(item, 'recurring_master_id', None)
    is_rec = getattr(item, 'is_recurring', None)
    
    if rec:
        m_type = "RecurringMaster"
    elif master_id:
        m_type = "Occurrence"
    elif is_rec is False:
        m_type = "Single"
    else:
        m_type = "Unknown"
    
    type_inferred = True
    if self.log_level_var.get() == "Advanced":
        self.log(f"  Type inferred (not from calendar_item_type): {m_type}", is_advanced=True)
```

### 推断优先级

1. **优先使用** `recurrence` 字段：若存在 ⇒ RecurringMaster
2. **其次** `recurring_master_id` 字段：若存在 ⇒ Occurrence  
3. **再次** `is_recurring` 字段：若为 False ⇒ Single
4. **最后** 默认为 Unknown

这个优先级基于字段的可靠性。

---

## 3. RecurringMasterId 兼容性改进

### 问题
在 exchangelib 中，`recurring_master_id` 有时是一个 `ItemId` 对象（包含 `.id` 和 `.changekey` 属性），不是纯字符串。

直接使用 `account.calendar.get(id=m_recurring_master_id)` 会失败。

### 解决方案

代码已经正确处理了这个情况：

```python
master_id = m_recurring_master_id
master_ck = None

# 检查是否为 ItemId 对象
if hasattr(master_id, "id"):
    # 是 ItemId 对象，提取 id 和 changekey
    master_ck = getattr(master_id, "changekey", None)
    master_id = master_id.id

# 使用提取的 id 和 changekey
master = account.calendar.get(id=master_id, changekey=master_ck) if master_ck else account.calendar.get(id=master_id)
```

这样可以兼容两种情况：
- `recurring_master_id` 是字符串
- `recurring_master_id` 是 ItemId 对象

---

## 4. additional_fields 的正确用法

### 澄清 "additional_fields must be a single value" 错误

这个错误发生在错误的调用方式：

```python
# ❌ 错误：在 filter() 的 additional_fields 参数中使用 list
account.calendar.filter(start=..., end=..., additional_fields=[...])
# 错误提示："additional_fields must be a single value"

# ✅ 正确：在 get() 或 refresh() 中使用 additional_fields
item = account.calendar.get(id=_id, changekey=_ck, additional_fields=[...])
item.refresh()  # 也可以带 additional_fields
```

**当前代码**已经使用了正确的方式（GetItem enrichment），所以不再出现这个错误。

---

## 5. 调试流程

### 如果 Type 或 RecurrencePattern 仍然不对，按以下步骤：

#### Step 1: 启用 Advanced 日志
- 打开应用
- 在 "日志级别" 选项中选择 **"Advanced"**
- 重新运行清理任务

#### Step 2: 查看诊断输出
搜索日志中的以下两类信息：

1. **ItemFields 诊断**（在 GetItem 富化后）：
   ```
   [EWS] ItemFields: PyType=<class 'exchangelib.items.calendar.CalendarItem'> ClassName=CalendarItem ItemClass=IPM.Appointment Type=Single UID=... RecurringMasterId=None IsRecurring=False HasRecurrence=False
   ```
   
   关键点：
   - 如果 `ItemClass=IPM.Schedule.Meeting.Request` 等非标准类，`Type` 为 `None` 是正常的 → 依赖推断
   - 如果 `ItemClass=IPM.Appointment`，`Type` 应该有值
   - `HasRecurrence=True` 表示 `recurrence` 对象存在

2. **Type inferred 日志**（若使用了推断）：
   ```
   Type inferred (not from calendar_item_type): Occurrence
   ```

3. **EWS 响应 XML**：搜索 `<Trace Tag="EwsResponse"` 和 `<t:CalendarItemType>`，检查服务端返回的值。

#### Step 3: 理解推断结果
- 若推断出 `Type=Occurrence`，但你期望 `RecurringMaster`，检查 `RecurringMasterId` 是否有值
- 若 `HasRecurrence=False` 但 `Type=Unknown`，可能是另外的问题（如 Exception 类型）
- 若服务端 `<t:CalendarItemType>` 为空但 exchangelib 收到了 recurrence 数据，推断会正确识别

#### Step 4: 收集日志文件
如果问题持续，收集：
- `%USERPROFILE%\Documents\UniversalEmailCleaner\app.log`
- `%USERPROFILE%\Documents\UniversalEmailCleaner\ews_trace_*.log`

分享关键的 `[EWS] ItemFields` 行和对应的 `<Trace Tag="EwsResponse"` 部分。

---

## 6. 更新摘要

| 改进项 | 说明 |
|--------|------|
| **Advanced 日志** | 现在包含 PyType、ClassName、ItemClass，便于识别非标准项 |
| **Type 推断** | 若 calendar_item_type 为空，使用 recurrence、recurring_master_id、is_recurring 推断 |
| **Scope 过滤** | 从硬卡 calendar_item_type 改为使用推断 Type，避免遗漏项 |
| **RecurringMasterId** | 正确处理 ItemId 对象，提取 .id 和 .changekey |
| **EWS 响应日志** | 捕获完整 XML 内容，便于确认服务端返回的 CalendarItemType 值 |

---

## 7. 技术细节

### 代码位置
- **Advanced 日志输出**：第 ~1130-1155 行（GetItem 富化后）
- **Scope 过滤推断**：第 ~1116-1142 行（scope filtering）
- **行详情推断**：第 ~1208-1238 行（Type 计算）
- **RecurringMasterId 处理**：第 ~1276-1286 行
- **TraceAdapter 响应日志**：第 ~140-173 行

### 依赖
- exchangelib: 用于 EWS 连接和 CalendarItem 操作
- 无新增第三方库

---

## 8. 向后兼容性

✅ 本版本**完全向后兼容**：
- 旧的配置、缓存、报告格式不变
- 仅改进了诊断和推断逻辑
- 若 calendar_item_type 有值，直接使用（不走推断）
- 若推断失败（Unknown），也会正确记录

---

## 反馈与下一步

如果运行 v1.2.23 后 Type 或 RecurrencePattern 仍有问题：
1. 启用 Advanced 日志
2. 收集 `[EWS] ItemFields` 的完整输出
3. 从日志中找到对应的 `<Trace Tag="EwsResponse">` 部分
4. 分享这些信息，便于进一步诊断

